; 문제 조건은 RGB 옵션이 아닌 상태에서 픽셀값이 FF0000인 레드를 찾는 것이지만
; 각 사용자의 상황에 따라 바탕화면에 완벽한 레드 픽셀이 없으면 
; 코드가 올바로 동작하는지 확인할 수 없다. 
; 따라서, Windows Spy를 이용해서 실재 화면에 있는 지점의 픽셀값을 
; 찾을 픽셀로 설정하여 코드를 검증한다. 
; 또한 RGB 옵션을 사용하지 말라고 하였으나, R값과 B값을 교체하는 것이
; 귀찮아서 그냥 RGB 옵션을 사용한다. 
; 그리고 PixelSearch 커맨드의 경우 내부 알고리즘이 어떻게 되는지 알수 없으나
; Fast 옵션을 사용하지 않으면 매우 느리다. 예를 들어 FHD 화면 전체를 한 픽셀씩
; 비교 검색한다고 가정하면 1920x1080=2,073,600 개의 픽셀을 비교 검색할 것이다.
; 이때 마치 프로그램이 서있는 것처럼 느껴질 수 있다. 따라서 처음에는 적당히 작은 
; 사이즈의 검색 공간을 설정하여 코드를 검증하는 것이 좋다.
; 마지막으로 문제 조건과는 다르게 찾은 픽셀에 대해 msgbox로 알린 후 확인을 누르면
; 그 지점으로 커서가 이동하도록 하였다.
; 결과를 보면 PixelSearch 커맨드는 좌측상단에서 검색을 시작해 가로방향으로 
; 순차 검색을 한 후 최초로 찾아지는 픽셀을 결과로 설정하는 것 같다.
cr := 0x0078D7
CoordMode, Pixel, Screen
CoordMode, Mouse, Screen
PixelSearch, px, py, 0, 0, 1920, 1080, cr, , Fast RGB
if (errorlevel = 0)
{
	MsgBox, % "rgb=" cr ": px=" px ", py=" py
	MouseMove, px, py
}
else
{
	MsgBox, % "rgb=" cr " 없음"
}
ExitApp
